use tok::{self, Tok};

grammar<'input>(text: &'input str)["LALR(1)"];

CommaList<T>: Vec<T> = {
    T => vec![<>],
    <v:CommaList<T>> "," <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
};
Qualified<T>: () =
    (DatabaseName ".")? T => ();

pub CmdList: Vec<Option<()>> = {
    <v:(<ExplainCmd?> ";")*> <e:ExplainCmd?> => match e {
        None => v,
        e => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub ExplainCmd: () =
    Explain? Cmd => ();
Explain: () = {
    "explain" => (),
    "explain" "query" "plan" => (),
};

pub Cmd: () = {
    Begin,
    Commit,
    Rollback,
    Savepoint,
    Release,
    CreateTable,
    DropTable,
    CreateView,
    DropView,
    Select,
    Delete,
    Update,
    Insert,
    CreateIndex,
    DropIndex,
    Vacuum,
    Pragma,
    CreateTrigger,
    DropTrigger,
    Attach,
    Detach,
    Reindex,
    Analyze,
    AlterTable,
    CreateVirtualTable,
};

///////////////////// Begin and end transactions. ////////////////////////////
TransactionName = Name;

Transaction: () =
    "transaction" Name? => ();

Begin: () =
    "begin" TransactionType? Transaction? => ();
TransactionType = {
    "deferred",
    "immediate",
    "exclusive",
};

Commit: () = {
    "commit" Transaction? => (),
    "end" Transaction? => (),
};

Rollback: () = {
    "rollback" Transaction? => (),
    "rollback" Transaction? "to" "savepoint"? SavepointName => ()
};

SavepointName = Name;

Savepoint: () =
    "savepoint" SavepointName => ();
Release: () =
    "release" "savepoint"? SavepointName => ();

///////////////////// The CREATE TABLE statement ////////////////////////////
DatabaseName = Name;
TableName = Name;

CreateTable: () =
    "create" "temp"? "table" IfNotExists? QualifiedTableName CreateTableBody => ();
CreateTableBody: () = {
    "(" CommaList<ColumnDef> ("," CommaList<NamedTableConstraint>)? ")" ("without" Name)? => (), // TODO check Name == "rowid"*
    "as" Select => (),
};

IfNotExists: () =
    "if" "not" "exists" => ();

ColumnName = Name;

Id: () = {
    "Id" => (),
    "indexed" => (),
    // TODO fallback
};

IdString: () = {
    Id => (),
    // TODO "StringLiteral",
};
// nm
Name: () = {
    Id => (),
    // TODO "StringLiteral",
    // TODO "cross", "inner", left", "natural", "outer", "right"
};

ConstraintName = Name;

ColumnDef: () =
    ColumnName TypeName? (("constraint" ConstraintName)? ColumnConstraint)* => ();

// fullname
QualifiedTableName = Qualified<TableName>;

// typetoken
TypeName: () = {
    IdString+ => (),
    IdString+ "(" SignedNumber ")" => (),
    IdString+ "(" SignedNumber "," SignedNumber ")" => (),
};
// signed
SignedNumber: () =
    (Sign)? NumericLiteral => ();
Sign: () = {
    "+" => (),
    "-" => (),
};
// number
NumericLiteral: () = {
    "Integer" => (),
    "Float" => (),
};

CollationName = IdString;

ColumnConstraint: () = {
    "primary" "key" SortOrder? ConflictClause? "autoincrement"? => (),
    "not"? "null" ConflictClause? => (),
    "unique" ConflictClause? => (),
    "check" "(" Expr ")" => (),
    "default" DefaultValue => (),
    "collate" CollationName => (),
    "references" TableName ("(" CommaList<IndexedColumn> ")")? RefArg* => (),
};

ConflictClause: () =
    "on" "conflict" ResolveType => ();
ResolveType: () = {
    RaiseType => (),
    "ignore" => (),
    "replace" => (),
};

DefaultValue: () = {
    LiteralValue => (),
    "(" Expr ")" => (),
    "+" LiteralValue => (), // Ambiguous grammar with SignedNumber and LiteralValue
    "-" LiteralValue => (),
    Id => (),
};

RefArg: () = {
    "on" "delete" RefAct => (),
    "on" "update" RefAct => (),
    "match" Name => (),
};
RefAct: () = {
    "set" "null" => (),
    "set" "default" => (),
    "cascade" => (),
    "restrict" => (),
    "no" "action" => (),
};

// term
LiteralValue: () = {
    NumericLiteral => (),
    "StringLiteral" => (),
    "Blob" => (),
    "null" => (),
    "current_date" => (),
    "current_time" => (),
    "current_timestamp" => (),
};

SortOrder = {
    "asc",
    "desc"
};

NamedTableConstraint: () =
    ("constraint" ConstraintName)? TableConstraint => ();
TableConstraint: () = {
    "primary" "key" "(" CommaList<SortedColumn> "autoincrement"? ")" ConflictClause? => (),
    "unique" "(" CommaList<SortedColumn> ")" ConflictClause? => (),
    "check" "(" Expr ")" => (),
    "foreign" "key" "(" CommaList<IndexedColumn> ")" "references" TableName ("(" CommaList<IndexedColumn> ")")? RefArg* DeferSubclause? => (),
};
 // sortlist
SortedColumn: () =
    Expr SortOrder? => ();
 // eidlist
IndexedColumn: () =
    ColumnName ("collate" CollationName)? SortOrder? => ();

DeferSubclause: () =
    "not"? "deferrable" InitDeferredPred? => ();
InitDeferredPred: () = {
    "initially" "deferred" => (),
    "initially" "immediate" => (),
};

////////////////////////// The DROP TABLE /////////////////////////////////////
DropTable: () =
    "drop" "table" IfExists? QualifiedTableName => ();
IfExists: () =
    "if" "exists" => ();

///////////////////// The CREATE VIEW statement /////////////////////////////
CreateView: () =
    "create" "temp"? "view" IfNotExists? QualifiedTableName ("(" CommaList<IndexedColumn> ")")? "as" Select => ();
DropView: () =
    "drop" "view" IfExists? QualifiedTableName => ();

//////////////////////// The SELECT statement /////////////////////////////////
Select: () =
    With? SelectNoWith => ();

SelectNoWith: () = {
    OneSelect => (),
    SelectNoWith CompoundOperator OneSelect => (),
};

CompoundOperator: () = {
        "union" => (),
        "union" "all" => (),
        "except" => (),
        "intersect" => (),
};

OneSelect: () = {
    "select" Distinct? CommaList<SelectColumn> From? Where? GroupBy? OrderBy? Limit? => (),
    Values => (),
};

Distinct: () = {
    "distinct" => (),
    "all" => (),
};

SelectColumn: () = {
    Expr As? => (),
    "*" => (),
    TableName "." "*" => (),
};

Values: () = {
    "values" "(" CommaList<Expr> ")" => (),
    Values "," "(" CommaList<Expr>? ")" => (),
};

As: () = {
    "as" Name => (),
    IdString => (),
};

From: () =
    "from" SelectTableList => ();

SelectTableList: () = {
    SelectTable => (),
    SelectTableList JoinOperator SelectTable => (),
};

SelectTable: () = {
    QualifiedTableName As? Indexed? On? Using? => (),
    QualifiedTableName "(" CommaList<Expr>? ")" As? On? Using? => (),
    "(" Select ")" As? On? Using? => (),
    "(" SelectTableList ")" As? On? Using? => (),
};

JoinOperator: () = {
    "," => (),
    "join" => (),
    "natural"? JoinType "join" => (),
};
JoinType: () = {
    "left" "outer"? => (),
    "inner" => (),
    "cross" => (),
};

On: () =
    "on" Expr => ();

IndexName = Name;

Indexed: () = {
    "indexed" "by" IndexName => (),
    "not" "indexed" => (),
};

Using: () =
    "using" "(" CommaList<ColumnName> ")" => ();

Where: () =
    "where" Expr => ();

GroupBy: () =
    "group" "by" CommaList<Expr> Having? => ();

Having: () =
    "having" Expr => ();

OrderBy: () =
    "order" "by" CommaList<SortedColumn> => ();

Limit: () = {
    "limit" Expr => (),
    "limit" Expr "offset" Expr => (),
    "limit" Expr "," Expr => (),
};

/////////////////////////// The DELETE statement /////////////////////////////
Delete: () =
    With? "delete" "from" QualifiedTableName Indexed? Where? OrderBy? Limit? => ();

////////////////////////// The UPDATE command ////////////////////////////////
Update: () =
    With? "update" OrConflict? QualifiedTableName Indexed? "set" CommaList<Set> Where? OrderBy? Limit? => ();
OrConflict:() =
    "or" ResolveType => ();
Set:() =
    ColumnName "=" Expr => ();

////////////////////////// The INSERT command /////////////////////////////////
Insert: () =
    With? InsertCmd "into" QualifiedTableName ("(" CommaList<ColumnName> ")")? InsertBody => ();
InsertCmd: () = {
    "insert" OrConflict? => (),
    "replace" => (),
};
InsertBody: () = {
    Select => (),
    "default" "values" => (),
};

/////////////////////////// Expression Processing /////////////////////////////
Expr: () = {
    LiteralValue => (),
    "(" Expr ")" => (),
    Id => (),
// TODO JOIN_KW
//    Name "." Name => (), // FIXME Ambiguity
//    Name "." Name "." Name => (),
    "Variable" => (),
// TODO precedence/associativity
//    Expr "collate" CollationName => (),
    "cast" "(" Expr "as" TypeName ")" => (),
    Id "(" Distinct? CommaList<Expr>? ")" => (),
    Id "(" "*" ")" => (),
// TODO precedence/associativity
//    Expr "and" Expr => (),
//    Expr "or" Expr => (),
//    Expr CompOperator Expr => (),
//    Expr EqOperator Expr => (),
//    Expr BitOperator Expr => (),
//    Expr "+" Expr => (),
//    Expr "-" Expr => (),
//    Expr "*" Expr => (),
//    Expr "/" Expr => (),
//    Expr "%" Expr => (),
//    Expr "||" Expr => (),
//    Expr "not"? LikeOperator Expr ("escape" Expr)? => (),
//    Expr "isnull" Expr => (),
//    Expr "notnull" Expr => (),
//    Expr "not" "null" Expr => (),
//    Expr "is" "not"? Expr => (),
    "not" Expr => (),
    "~" Expr => (),
    "-" Expr => (),
    "+" Expr => (),
//    Expr "not"? "between" Expr "and" Expr => (),
//    Expr "not"? "in" "(" Expr ")" => (),
    "(" Select ")" => (),
//    Expr "not"? "in" "(" Select ")" => (),
//    Expr "not"? "in" QualifiedTableName => (),
    "exists" "(" Select ")" => (),
    "case" Expr? ("when" Expr "then" Expr)+ ("else" Expr?) "end" => (),
    "raise" "(" "ignore" ")" => (),
    "raise" "(" RaiseType "," Name ")" => (),
    // TODO
};

CompOperator: () = {
    ">" => (),
    "=>" => (),
    "<=" => (),
    "<" => (),
};
EqOperator: () = {
    "=" => (),
    "<>" => (),
};
BitOperator: () = {
    "&" => (),
    "~" => (),
    "|" => (),
    "<<" => (),
    ">>" => (),
};
LikeOperator: () = {
    "like" => (),
    "match" => (),
    // TODO glob, regexp
};

RaiseType = {
    "rollback",
    "abort",
    "fail",
};

///////////////////////////// The CREATE INDEX command ///////////////////////
CreateIndex: () =
    "create" "unique"? "index" IfNotExists? Qualified<IndexName> "on" TableName "(" CommaList<SortedColumn> ")" Where? => ();
///////////////////////////// The DROP INDEX command /////////////////////////
DropIndex: () =
    "drop" "index" IfExists? Qualified<IndexName> => ();

///////////////////////////// The VACUUM command /////////////////////////////
Vacuum: () =
    "vacuum" DatabaseName? => ();

///////////////////////////// The PRAGMA command /////////////////////////////
PragmaName = Name;

Pragma: () =
    "pragma" Qualified<PragmaName> PragmaBody? => ();
PragmaBody: () = {
    "=" PragmaValue => (),
    "(" PragmaValue ")" => (),
};
PragmaValue: () = {
    SignedNumber => (),
    Name => (),
    "on" => (),
    "delete" => (),
    "default" => (),
};

//////////////////////////// The CREATE TRIGGER command /////////////////////
TriggerName = Name;

// FIXME ";" between TriggerCmd
CreateTrigger: () =
    "create" TriggerDecl "begin" TriggerCmd+ "end" => ();
TriggerDecl: () =
    "temp"? "trigger" IfNotExists? Qualified<TriggerName> TriggerTime? TriggerEvent "on" QualifiedTableName ForEachRow? WhenClause? => ();
TriggerTime: () = {
    "before" => (),
    "after" => (),
    "instead" "of" => (),
};
TriggerEvent: () = {
    "delete" => (),
    "insert" => (),
    "update" => (),
    "update" "of" CommaList<ColumnName> => (),
};
ForEachRow: () =
    "for" "each" "row" => ();
WhenClause: () =
    "when" Expr => ();
// Disallow qualified table names on INSERT, UPDATE, and DELETE statements
// within a trigger. The table to INSERT, UPDATE, or DELETE is always in
// the same database as the table that the trigger fires on.
TriggerCmd: () = {
    "update" OrConflict? TableName "set" CommaList<Set> Where? => (),
    "insert" "into" TableName ("(" CommaList<ColumnName> ")")? Select => (),
    "delete" "from" TableName Where? => (),
    Select => (),
};

//////////////////////// DROP TRIGGER statement //////////////////////////////
DropTrigger: () =
    "drop" "trigger" IfExists? Qualified<TriggerName> => ();

//////////////////////// ATTACH DATABASE file AS name /////////////////////////
Attach: () =
    "attach" "database"? Expr "as" Expr ("key" Expr)? => ();
Detach: () =
    "detach" "database"? Expr => ();

////////////////////////// REINDEX collation //////////////////////////////////
Reindex: () =
    "reindex" QualifiedTableName? => ();

/////////////////////////////////// ANALYZE ///////////////////////////////////
Analyze: () =
    "analyze" QualifiedTableName? => ();

//////////////////////// ALTER TABLE table ... ////////////////////////////////
AlterTable: () =
    "alter" "table" QualifiedTableName AlterTableBody => ();
AlterTableBody: () = {
    "rename" "to" TableName => (),
    "add" "column"? ColumnDef => (),
};

//////////////////////// CREATE VIRTUAL TABLE ... /////////////////////////////
ModuleName = Name;

CreateVirtualTable: () =
    "create" "virtual" "table" IfNotExists? QualifiedTableName "using" ModuleName ("(" CommaList<VirtualTableArg>? ")")? => ();

VirtualTableArg: () = {
    "StringLiteral" => (),
    "Id" => (),
    NumericLiteral => (),
    // TODO ANY
};

//////////////////////// COMMON TABLE EXPRESSIONS ////////////////////////////
With: () =
    "with" "recursive"? CommaList<WithQuery> => ();
WithQuery: () =
    TableName ("(" CommaList<IndexedColumn> ")")? "as" "(" Select ")" => ();

extern {
    type Location = usize;
    type Error = tok::Error;
    enum Tok<'input> {
        "abort" => Tok::Abort,
        "action" => Tok::Action,
        "add" => Tok::Add,
        "after" => Tok::After,
        "all" => Tok::All,
        "alter" => Tok::Alter,
        "analyze" => Tok::Analyze,
        "and" => Tok::And,
        "as" => Tok::As,
        "asc" => Tok::Asc,
        "attach" => Tok::Attach,
        "autoincrement" => Tok::Autoincr,
        "before" => Tok::Before,
        "begin" => Tok::Begin,
        "between" => Tok::Between,
        "by" => Tok::By,
        "cascade" => Tok::Cascade,
        "case" => Tok::Case,
        "cast" => Tok::Cast,
        "check" => Tok::Check,
        "collate" => Tok::Collate,
        "column" => Tok::ColumnKw,
        "commit" => Tok::Commit,
        "conflict" => Tok::Conflict,
        "constraint" => Tok::Constraint,
        "create" => Tok::Create,
        "cross" => Tok::Cross,
        "current_date" => Tok::CurrentDate,
        "current_time" => Tok::CurrentTime,
        "current_timestamp" => Tok::CurrentTimestamp,
        "database" => Tok::Database,
        "default" => Tok::Default,
        "deferrable" => Tok::Deferrable,
        "deferred" => Tok::Deferred,
        "delete" => Tok::Delete,
        "desc" => Tok::Desc,
        "detach" => Tok::Detach,
        "distinct" => Tok::Distinct,
        "drop" => Tok::Drop,
        "each" => Tok::Each,
        "else" => Tok::Else,
        "end" => Tok::End,
        "escape" => Tok::Escape,
        "except" => Tok::Except,
        "exclusive" => Tok::Exclusive,
        "exists" => Tok::Exists,
        "explain" => Tok::Explain,
        "fail" => Tok::Fail,
        "for" => Tok::For,
        "foreign" => Tok::Foreign,
        "from" => Tok::From,
        "full" => Tok::Full,
        "glob" => Tok::Glob,
        "group" => Tok::Group,
        "having" => Tok::Having,
        "if" => Tok::If,
        "ignore" => Tok::Ignore,
        "immediate" => Tok::Immediate,
        "in" => Tok::In,
        "index" => Tok::Index,
        "indexed" => Tok::Indexed,
        "initially" => Tok::Initially,
        "inner" => Tok::Inner,
        "insert" => Tok::Insert,
        "instead" => Tok::Instead,
        "intersect" => Tok::Intersect,
        "into" => Tok::Into,
        "is" => Tok::Is,
        "isnull" => Tok::IsNull,
        "join" => Tok::Join,
        "key" => Tok::Key,
        "left" => Tok::Left,
        "like" => Tok::Like,
        "limit" => Tok::Limit,
        "match" => Tok::Match,
        "natural" => Tok::Natural,
        "no" => Tok::No,
        "not" => Tok::Not,
        "notnull" => Tok::NotNull,
        "null" => Tok::Null,
        "of" => Tok::Of,
        "offset" => Tok::Offset,
        "on" => Tok::On,
        "or" => Tok::Or,
        "order" => Tok::Order,
        "outer" => Tok::Outer,
        "plan" => Tok::Plan,
        "pragma" => Tok::Pragma,
        "primary" => Tok::Primary,
        "query" => Tok::Query,
        "raise" => Tok::Raise,
        "recursive" => Tok::Recursive,
        "references" => Tok::References,
        "regexp" => Tok::Regexp,
        "reindex" => Tok::Reindex,
        "release" => Tok::Release,
        "rename" => Tok::Rename,
        "replace" => Tok::Replace,
        "restrict" => Tok::Restrict,
        "right" => Tok::Right,
        "rollback" => Tok::Rollback,
        "row" => Tok::Row,
        "savepoint" => Tok::Savepoint,
        "select" => Tok::Select,
        "set" => Tok::Set,
        "table" => Tok::Table,
        "temp" => Tok::Temp,
        "then" => Tok::Then,
        "to" => Tok::To,
        "transaction" => Tok::Transaction,
        "trigger" => Tok::Trigger,
        "union" => Tok::Union,
        "unique" => Tok::Unique,
        "update" => Tok::Update,
        "using" => Tok::Using,
        "vacuum" => Tok::Vacuum,
        "values" => Tok::Values,
        "view" => Tok::View,
        "virtual" => Tok::Virtual,
        "when" => Tok::When,
        "where" => Tok::Where,
        "with" => Tok::With,
        "without" => Tok::Without,

        "StringLiteral" => Tok::StringLiteral(<&'input str>),
        "Id" => Tok::Id(<&'input str>),
        "Variable" => Tok::Variable(<&'input str>),

        "Blob" => Tok::Blob(<&'input str>),
        "Integer" => Tok::Integer(<&'input str>),
        "Float" => Tok::Float(<&'input str>),

        "&" => Tok::BitAnd,
        "~" => Tok::BitNot,
        "|" => Tok::BitOr,
        "," => Tok::Comma,
        "||" => Tok::Concat,
        "." => Tok::Dot,
        "=" => Tok::Equals,
        ">" => Tok::GreaterThan,
        "=>" => Tok::GreaterEquals,
        "(" => Tok::LeftParen,
        "<<" => Tok::LeftShift,
        "<=" => Tok::LessEquals,
        "<" => Tok::LessThan,
        "-" => Tok::Minus,
        "<>" => Tok::NotEquals,
        "+" => Tok::Plus,
        "%" => Tok::Reminder,
        ")" => Tok::RightParen,
        ">>" => Tok::RightShift,
        ";" => Tok::Semi,
        "/" => Tok::Slash,
        "*" => Tok::Star,
    }
}
